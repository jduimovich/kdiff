apiVersion: v1
kind: Namespace
metadata:
  labels:
    control-plane: controller-manager
  name: image-controller
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.16.3
  name: imagerepositories.appstudio.redhat.com
spec:
  group: appstudio.redhat.com
  names:
    kind: ImageRepository
    listKind: ImageRepositoryList
    plural: imagerepositories
    singular: imagerepository
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.image.url
      name: Image
      type: string
    - jsonPath: .status.image.visibility
      name: Visibility
      type: string
    name: v1alpha1
    schema:
      openAPIV3Schema:
        description: ImageRepository is the Schema for the imagerepositories API
        properties:
          apiVersion:
            description: |-
              APIVersion defines the versioned schema of this representation of an object.
              Servers should convert recognized schemas to the latest internal value, and
              may reject unrecognized values.
              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            type: string
          kind:
            description: |-
              Kind is a string value representing the REST resource this object represents.
              Servers may infer this from the endpoint the client submits requests to.
              Cannot be updated.
              In CamelCase.
              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            type: string
          metadata:
            type: object
          spec:
            description: ImageRepositorySpec defines the desired state of ImageRepository
            properties:
              credentials:
                description: Credentials management.
                properties:
                  regenerate-token:
                    description: |-
                      RegenerateToken defines a request to refresh image accessing credentials.
                      Refreshes both, push and pull tokens.
                      The field gets cleared after the refresh.
                    type: boolean
                  verify-linking:
                    description: |-
                      VerifyLinking defines a request to verify and fix
                      secret linking in pipeline service account.
                      The field gets cleared after fixing.
                    type: boolean
                type: object
              image:
                description: Requested image repository configuration.
                properties:
                  name:
                    description: |-
                      Name of the image within configured Quay organization.
                      If ommited, then defaults to "cr-namespace/cr-name".
                      This field cannot be changed after the resource creation.
                    pattern: ^[a-z0-9][.a-z0-9_-]*(/[a-z0-9][.a-z0-9_-]*)*$
                    type: string
                  visibility:
                    description: |-
                      Visibility defines whether the image is publicly visible.
                      Allowed values are public and private.
                      "public" is the default.
                    enum:
                    - public
                    - private
                    type: string
                type: object
              notifications:
                description: Notifications defines configuration for image repository
                  notifications.
                items:
                  properties:
                    config:
                      properties:
                        email:
                          description: Email is the email address to send notifications
                            to.
                          type: string
                        url:
                          description: Webhook is the URL to send notifications to.
                          type: string
                      type: object
                    event:
                      enum:
                      - repo_push
                      type: string
                    method:
                      enum:
                      - email
                      - webhook
                      type: string
                    title:
                      type: string
                  type: object
                type: array
            type: object
          status:
            description: ImageRepositoryStatus defines the observed state of ImageRepository
            properties:
              credentials:
                description: Credentials contain information related to image repository
                  credentials.
                properties:
                  generationTimestamp:
                    description: GenerationTime shows timestamp when the current credentials
                      were generated.
                    format: date-time
                    type: string
                  pull-robot-account:
                    description: |-
                      PullRobotAccountName is present only if ImageRepository has labels that connect it to Application and Component.
                      Holds name of the quay robot account with real (pull only) permissions from the generated repository.
                    type: string
                  pull-secret:
                    description: |-
                      PullSecretName is present only if ImageRepository has labels that connect it to Application and Component.
                      Holds name of the dockerconfig secret with credentials to pull only from the generated repository.
                      The secret might not be present in the same namespace as ImageRepository, but created in other environments.
                    type: string
                  push-robot-account:
                    description: PushRobotAccountName holds name of the quay robot
                      account with write (push and pull) permissions into the generated
                      repository.
                    type: string
                  push-secret:
                    description: PushSecretName holds name of the dockerconfig secret
                      with credentials to push (and pull) into the generated repository.
                    type: string
                type: object
              image:
                description: Image describes actual state of the image repository.
                properties:
                  url:
                    description: URL is the full image repository url to push into
                      / pull from.
                    type: string
                  visibility:
                    allOf:
                    - enum:
                      - public
                      - private
                    - enum:
                      - public
                      - private
                    description: Visibility shows actual generated image repository
                      visibility.
                    type: string
                type: object
              message:
                description: |-
                  Message shows error information for the request.
                  It could contain non critical error, like failed to change image visibility,
                  while the state is ready and image resitory could be used.
                type: string
              notifications:
                description: Notifications shows the status of the notifications configuration.
                items:
                  description: NotificationStatus shows the status of the notification
                    configuration.
                  properties:
                    title:
                      type: string
                    uuid:
                      type: string
                  type: object
                type: array
              state:
                description: |-
                  State shows if image repository could be used.
                  "ready" means repository was created and usable,
                  "failed" means that the image repository creation request failed.
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: image-controller-controller-manager
  namespace: image-controller
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: metrics-reader
  namespace: image-controller
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: image-controller-admin
  namespace: image-controller
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: image-controller-leader-election-role
  namespace: image-controller
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: image-controller-maintainer
rules:
- apiGroups:
  - appstudio.redhat.com
  resources:
  - imagerepositories
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - appstudio.redhat.com
  resources:
  - imagerepositories/status
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: image-controller-manager-role
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - appstudio.redhat.com
  resources:
  - components
  verbs:
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - appstudio.redhat.com
  resources:
  - imagerepositories
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - appstudio.redhat.com
  resources:
  - imagerepositories/finalizers
  verbs:
  - update
- apiGroups:
  - appstudio.redhat.com
  resources:
  - imagerepositories/status
  verbs:
  - get
  - patch
  - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: image-controller-metrics-reader
rules:
- nonResourceURLs:
  - /metrics
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: image-controller-proxy-role
rules:
- apiGroups:
  - authentication.k8s.io
  resources:
  - tokenreviews
  verbs:
  - create
- apiGroups:
  - authorization.k8s.io
  resources:
  - subjectaccessreviews
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: grant-argocd
  namespace: image-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
subjects:
- kind: ServiceAccount
  name: openshift-gitops-argocd-application-controller
  namespace: openshift-gitops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: image-controller-admins
  namespace: image-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: image-controller-admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: konflux-build-admins
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: image-controller-leader-election-rolebinding
  namespace: image-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: image-controller-leader-election-role
subjects:
- kind: ServiceAccount
  name: image-controller-controller-manager
  namespace: image-controller
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: image-controller-maintainers
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: image-controller-maintainer
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: konflux-build
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: image-controller-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: image-controller-manager-role
subjects:
- kind: ServiceAccount
  name: image-controller-controller-manager
  namespace: image-controller
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: image-controller-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: image-controller-proxy-role
subjects:
- kind: ServiceAccount
  name: image-controller-controller-manager
  namespace: image-controller
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus-image-controller-metrics-reader
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: image-controller-metrics-reader
subjects:
- kind: ServiceAccount
  name: metrics-reader
  namespace: image-controller
---
apiVersion: v1
data:
  prune_images.py: |
    import argparse
    import itertools
    import json
    import logging
    import os
    import re

    from collections.abc import Iterator
    from http.client import HTTPResponse
    from typing import Any, Dict, List
    from urllib.error import HTTPError
    from urllib.parse import urlencode
    from urllib.request import Request, urlopen

    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO
    )
    LOGGER = logging.getLogger(__name__)
    QUAY_API_URL = "https://quay.io/api/v1"

    processed_repos_counter = itertools.count()


    ImageRepo = Dict[str, Any]


    def get_quay_tags(quay_token: str, namespace: str, name: str) -> List[ImageRepo]:
        next_page = None
        resp: HTTPResponse

        all_tags = []
        while True:
            query_args = {"limit": 100, "onlyActiveTags": True}
            if next_page is not None:
                query_args["page"] = next_page

            api_url = f"{QUAY_API_URL}/repository/{namespace}/{name}/tag/?{urlencode(query_args)}"
            request = Request(api_url, headers={
                "Authorization": f"Bearer {quay_token}",
            })

            with urlopen(request) as resp:
                if resp.status != 200:
                    raise RuntimeError(resp.reason)
                json_data = json.loads(resp.read())

            tags = json_data.get("tags", [])
            all_tags.extend(tags)

            if not tags:
                LOGGER.debug("No tags found.")
                break

            page = json_data.get("page", None)
            additional = json_data.get("has_additional", False)

            if additional:
                next_page = page + 1
            else:
                break

        return all_tags


    def delete_image_tag(quay_token: str, namespace: str, name: str, tag: str) -> None:
        api_url = f"{QUAY_API_URL}/repository/{namespace}/{name}/tag/{tag}"
        request = Request(api_url, method="DELETE", headers={
            "Authorization": f"Bearer {quay_token}",
        })
        resp: HTTPResponse
        try:
            with urlopen(request) as resp:
                if resp.status != 200 and resp.status != 204:
                    raise RuntimeError(resp.reason)

        except HTTPError as ex:
            # ignore if not found
            if ex.status != 404:
                raise(ex)


    def manifest_exists(quay_token: str, namespace: str, name: str, manifest: str) -> bool:
        api_url = f"{QUAY_API_URL}/repository/{namespace}/{name}/manifest/{manifest}"
        request = Request(api_url, headers={
            "Authorization": f"Bearer {quay_token}",
        })
        resp: HTTPResponse
        manifest_exists = True
        try:
            with urlopen(request) as resp:
                if resp.status != 200 and resp.status != 204:
                    raise RuntimeError(resp.reason)

        except HTTPError as ex:
            if ex.status != 404:
                raise(ex)
            else:
                manifest_exists = False

        return manifest_exists


    def remove_tags(tags: List[Dict[str, Any]], quay_token: str, namespace: str, name: str, dry_run: bool = False) -> None:
        image_digests = [image["manifest_digest"] for image in tags]
        tags_map = {tag_info["name"]: tag_info for tag_info in tags}
        tag_regex = re.compile(r"^sha256-([0-9a-f]+)(\.sbom|\.att|\.src|\.sig|\.dockerfile)$")
        manifests_checked = {}
        for tag in tags:
            # attestation or sbom image
            if (match := tag_regex.match(tag["name"])) is not None:
                if f"sha256:{match.group(1)}" not in image_digests:
                    # verify that manifest really doesn't exist, because if tag was removed, it won't be in tag list, but may still be in the registry
                    manifest_existence = manifests_checked.get(f"sha256:{match.group(1)}")
                    if manifest_existence is None:
                        manifest_existence = manifest_exists(quay_token, namespace, name, f"sha256:{match.group(1)}")
                        manifests_checked[f"sha256:{match.group(1)}"] = manifest_existence

                    if not manifest_existence:
                        if dry_run:
                            LOGGER.info("Tag %s from %s/%s should be removed", tag["name"], namespace, name)
                        else:
                            LOGGER.info("Removing tag %s from %s/%s", tag["name"], namespace, name)
                            delete_image_tag(quay_token, namespace, name, tag["name"])

            elif tag["name"].endswith(".src"):
                to_delete = False

                binary_tag = tag["name"].removesuffix(".src")
                if binary_tag not in tags_map:
                    to_delete = True
                else:
                    manifest_digest = tags_map[binary_tag]["manifest_digest"]
                    new_src_tag = f"{manifest_digest.replace(':', '-')}.src"
                    to_delete = new_src_tag in tags_map

                if to_delete:
                    LOGGER.info("Removing deprecated tag %s", tag["name"])
                    delete_image_tag(quay_token, namespace, name, tag["name"])
            else:
                LOGGER.debug("%s is not in a known type to be deleted.", tag["name"])


    def process_repositories(repos: List[ImageRepo], quay_token: str, dry_run: bool = False) -> None:
        for repo in repos:
            namespace = repo["namespace"]
            name = repo["name"]
            LOGGER.info("Processing repository %s: %s/%s", next(processed_repos_counter), namespace, name)
            all_tags = get_quay_tags(quay_token, namespace, name)

            if not all_tags:
                continue

            remove_tags(all_tags, quay_token, namespace, name, dry_run=dry_run)


    def fetch_image_repos(access_token: str, namespace: str) -> Iterator[List[ImageRepo]]:
        next_page = None
        resp: HTTPResponse
        while True:
            query_args = {"namespace": namespace}
            if next_page is not None:
                query_args["next_page"] = next_page

            api_url = f"{QUAY_API_URL}/repository?{urlencode(query_args)}"
            request = Request(api_url, headers={
                "Authorization": f"Bearer {access_token}",
            })

            with urlopen(request) as resp:
                if resp.status != 200:
                    raise RuntimeError(resp.reason)
                json_data = json.loads(resp.read())

            repos = json_data.get("repositories", [])
            if not repos:
                LOGGER.debug("No image repository is found.")
                break

            yield repos

            if (next_page := json_data.get("next_page", None)) is None:
                break


    def main():
        token = os.getenv("QUAY_TOKEN")
        if not token:
            raise ValueError("The token required for access to Quay API is missing!")

        args = parse_args()

        for image_repos in fetch_image_repos(token, args.namespace):
            process_repositories(image_repos, token, dry_run=args.dry_run)


    def parse_args():
        parser = argparse.ArgumentParser()
        parser.add_argument("--namespace", required=True)
        parser.add_argument("--dry-run", action="store_true")
        args = parser.parse_args()
        return args


    if __name__ == "__main__":
        main()
kind: ConfigMap
metadata:
  name: image-controller-image-pruner-configmap-cbd96747df
  namespace: image-controller
---
apiVersion: v1
data:
  controller_manager_config.yaml: |
    apiVersion: controller-runtime.sigs.k8s.io/v1alpha1
    kind: ControllerManagerConfig
    health:
      healthProbeBindAddress: :8081
    metrics:
      bindAddress: 127.0.0.1:8080
    leaderElection:
      leaderElect: true
      resourceName: ed4c18c3.appstudio.redhat.com
    # leaderElectionReleaseOnCancel defines if the leader should step down volume
    # when the Manager ends. This requires the binary to immediately end when the
    # Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
    # speeds up voluntary leader transitions as the new leader don't have to wait
    # LeaseDuration time first.
    # In the default scaffold provided, the program ends immediately after
    # the manager stops, so would be fine to enable this option. However,
    # if you are doing or is intended to do any operation such as perform cleanups
    # after the manager stops then its usage might be unsafe.
    # leaderElectionReleaseOnCancel: true
kind: ConfigMap
metadata:
  name: image-controller-manager-config
  namespace: image-controller
---
apiVersion: v1
data:
  prune_images.py: |
    import argparse
    import itertools
    import json
    import logging
    import os
    import re
    import time

    from collections.abc import Iterator
    from http.client import HTTPResponse
    from typing import Any, Dict, List
    from urllib.error import HTTPError
    from urllib.parse import urlencode
    from urllib.request import Request, urlopen
    from datetime import datetime

    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO
    )
    LOGGER = logging.getLogger(__name__)
    QUAY_API_URL = "https://quay.io/api/v1"
    DAY_OLD_TS = int(datetime.now().timestamp()) - (60 * 60 * 24)
    KEEP_MAX = 3

    ImageRepo = Dict[str, Any]


    def get_quay_tags(quay_token: str, namespace: str, name: str) -> ImageRepo:
        next_page = None
        resp: HTTPResponse

        all_tags = []
        while True:
            query_args = {"limit": 100, "onlyActiveTags": True}
            if next_page is not None:
                query_args["page"] = next_page

            api_url = f"{QUAY_API_URL}/repository/{namespace}/{name}/tag/?{urlencode(query_args)}"
            request = Request(api_url, headers={
                "Authorization": f"Bearer {quay_token}",
            })

            with urlopen(request) as resp:
                if resp.status != 200:
                    raise RuntimeError(resp.reason)
                json_data = json.loads(resp.read())

            tags = json_data.get("tags", [])
            all_tags.extend(tags)

            if not tags:
                LOGGER.debug("No tags found.")
                break

            page = json_data.get("page", None)
            additional = json_data.get("has_additional", False)

            if additional:
                next_page = page + 1
            else:
                break

        return all_tags


    def quay_test_token(quay_token: str, namespace: str) -> None:
        api_url = f"{QUAY_API_URL}/organization/{namespace}/applications"
        request = Request(api_url, headers={
            "Authorization": f"Bearer {quay_token}",
        })
        try:
            urlopen(request)
        except HTTPError as ex:
            # if status is 401 that means that token is wrong
            if ex.status == 401:
                raise RuntimeError("Wrong quay token")


    def delete_image_tag(quay_token: str, namespace: str, name: str, tag: str) -> None:
        api_url = f"{QUAY_API_URL}/repository/{namespace}/{name}/tag/{tag}"
        request = Request(api_url, method="DELETE", headers={
            "Authorization": f"Bearer {quay_token}",
        })
        resp: HTTPResponse

        while True:
            try:
                with urlopen(request) as resp:
                    if resp.status != 200 and resp.status != 204 and resp.status != 404:
                        raise RuntimeError(resp.reason)
                    else:
                        break
            except HTTPError as ex:
                LOGGER.info("HTTPError exception: %s", ex)


    def remove_leftover_tags(tags: List[Dict[str, Any]], quay_token: str, namespace: str, name: str,
                             dry_run: bool = False) -> None:
        tag_regex = re.compile(r"^sha256-([0-9a-f]+)(\.sbom|\.att|\.src|\.sig)$")

        # remove att/sbom/src/sig for which is missing manifest digest
        image_digests = [image["manifest_digest"] for image in tags]

        for tag in tags:
            if (match := tag_regex.match(tag["name"])) is not None:
                if f"sha256:{match.group(1)}" not in image_digests:
                    if dry_run:
                        LOGGER.info("Leftover image %s from %s/%s should be removed", tag["name"], namespace, name)
                    else:
                        LOGGER.info("Removing leftover image %s from %s/%s", tag["name"], namespace, name)
                        delete_image_tag(quay_token, namespace, name, tag["name"])


    def remove_tags(tags: List[Dict[str, Any]], quay_token: str, namespace: str, name: str,
                    days_old: int, keep_max: int, dry_run: bool = False) -> None:
        unique_names = {}
        removed_digests = []

        # first remove only named tags
        for tag in tags:
            # skip att/sbom/src/sig
            if tag["name"].startswith("sha256-") or "-" not in tag["name"]:
                continue

            tag_name, _ = tag["name"].rsplit('-', 1)

            count = unique_names.get(tag_name, 0)

            # keep at least first x per tag name
            if count < keep_max:
                unique_names[tag_name] = count + 1

            # remove older than x
            elif tag["start_ts"] < days_old:
                if dry_run:
                    LOGGER.info("Image %s from %s/%s should be removed", tag["name"], namespace, name)
                    removed_digests.append(tag["manifest_digest"])
                else:
                    LOGGER.info("Removing image %s from %s/%s", tag["name"], namespace, name)
                    delete_image_tag(quay_token, namespace, name, tag["name"])
                    removed_digests.append(tag["manifest_digest"])

        tag_regex = re.compile(r"^sha256-([0-9a-f]+)(\.sbom|\.att|\.src|\.sig)$")
        # when named tags are removed, remove obsolete sbom/att/src
        for tag in tags:
            if (match := tag_regex.match(tag["name"])) is not None:
                if f"sha256:{match.group(1)}" in removed_digests:
                    if dry_run:
                        LOGGER.info("Image %s from %s/%s should be removed", tag["name"], namespace, name)
                    else:
                        LOGGER.info("Removing image %s from %s/%s", tag["name"], namespace, name)
                        delete_image_tag(quay_token, namespace, name, tag["name"])


    def process_repository(quay_token: str, namespace: str, repo_name: str, days_old: int,
                           keep_max: int, dry_run: bool = False) -> None:
        LOGGER.info("Processing repository: %s/%s", namespace, repo_name)

        quay_test_token(quay_token, namespace)

        all_tags = get_quay_tags(quay_token, namespace, repo_name)
        LOGGER.info("Tag count in repository: %s", len(all_tags))

        if all_tags:
            remove_tags(all_tags, quay_token, namespace, repo_name, days_old, keep_max, dry_run=dry_run)

        all_tags = get_quay_tags(quay_token, namespace, repo_name)
        LOGGER.info("Tag count in repository: %s", len(all_tags))

        if all_tags:
            remove_leftover_tags(all_tags, quay_token, namespace, repo_name, dry_run=dry_run)


    def main():
        token = os.getenv("QUAY_TOKEN")
        if not token:
            raise ValueError("The token required for access to Quay API is missing!")

        args = parse_args()
        process_repository(token, args.namespace, args.repo_name, days_old=args.old_days,
                           keep_max=args.keep_max, dry_run=args.dry_run)


    def parse_args():
        parser = argparse.ArgumentParser()
        parser.add_argument("--namespace", required=True)
        parser.add_argument("--repo-name", required=True)
        parser.add_argument("--dry-run", action="store_true")
        parser.add_argument("--old-days", type=int, default=DAY_OLD_TS)
        parser.add_argument("--keep-max", type=int, default=KEEP_MAX)

        args = parser.parse_args()
        return args


    if __name__ == "__main__":
        main()
kind: ConfigMap
metadata:
  name: single-image-pruner-configmap-f4hc5877h6
  namespace: image-controller
---
apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: metrics-reader
  name: metrics-reader
  namespace: image-controller
type: kubernetes.io/service-account-token
---
apiVersion: v1
kind: Service
metadata:
  labels:
    control-plane: controller-manager
  name: image-controller-controller-manager-metrics-service
  namespace: image-controller
spec:
  ports:
  - name: https
    port: 8443
    protocol: TCP
    targetPort: https
  selector:
    control-plane: controller-manager
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    control-plane: controller-manager
  name: image-controller-controller-manager
  namespace: image-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: controller-manager
  template:
    metadata:
      annotations:
        kubectl.kubernetes.io/default-container: manager
      labels:
        control-plane: controller-manager
    spec:
      containers:
      - args:
        - --health-probe-bind-address=:8081
        - --metrics-bind-address=127.0.0.1:8080
        - --leader-elect
        command:
        - /manager
        image: quay.io/konflux-ci/image-controller:3c98f2d567f39fc7f0cb21e209969f5966d0028f
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8081
          initialDelaySeconds: 15
          periodSeconds: 20
        name: manager
        ports:
        - containerPort: 8081
          name: probes
          protocol: TCP
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8081
          initialDelaySeconds: 5
          periodSeconds: 10
        resources:
          limits:
            cpu: 500m
            memory: 2Gi
          requests:
            cpu: 100m
            memory: 20Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
        volumeMounts:
        - mountPath: /workspace
          name: quaytoken
          readOnly: true
      - args:
        - --http2-disable
        - --secure-listen-address=0.0.0.0:8443
        - --upstream=http://127.0.0.1:8080/
        - --logtostderr=true
        - --v=0
        image: gcr.io/kubebuilder/kube-rbac-proxy:v0.15.0
        name: kube-rbac-proxy
        ports:
        - containerPort: 8443
          name: https
          protocol: TCP
        resources:
          limits:
            cpu: 500m
            memory: 128Mi
          requests:
            cpu: 5m
            memory: 64Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
      securityContext:
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      serviceAccountName: image-controller-controller-manager
      terminationGracePeriodSeconds: 10
      volumes:
      - name: quaytoken
        secret:
          secretName: quaytoken
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: image-controller-image-pruner-cronjob
  namespace: image-controller
spec:
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - command:
            - /bin/bash
            - -c
            - python /image-pruner/prune_images.py --namespace $(NAMESPACE)
            env:
            - name: QUAY_TOKEN
              valueFrom:
                secretKeyRef:
                  key: quaytoken
                  name: quaytoken
            - name: NAMESPACE
              valueFrom:
                secretKeyRef:
                  key: organization
                  name: quaytoken
            image: registry.redhat.io/rhel8/python-39:1-120.1684740828
            imagePullPolicy: IfNotPresent
            name: image-pruner
            resources:
              limits:
                cpu: 500m
                memory: 512Mi
              requests:
                cpu: 150m
                memory: 128Mi
            securityContext:
              readOnlyRootFilesystem: true
            volumeMounts:
            - mountPath: /image-pruner
              name: image-pruner-volume
          restartPolicy: OnFailure
          securityContext:
            runAsNonRoot: true
          volumes:
          - configMap:
              name: image-controller-image-pruner-configmap-cbd96747df
            name: image-pruner-volume
          - name: quaytoken
            secret:
              secretName: quaytoken
  schedule: 0 0 * * *
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: konflux-ci-pull-request-builds-pruner-cronjob
  namespace: image-controller
spec:
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - command:
            - /bin/bash
            - -c
            - python /image-pruner/prune_images.py --namespace=konflux-ci --repo-name=pull-request-builds
            env:
            - name: QUAY_TOKEN
              valueFrom:
                secretKeyRef:
                  key: quaytoken
                  name: konflux-ci-pull-request-builds-pruner-token
            image: registry.redhat.io/rhel8/python-39:1-120.1684740828
            imagePullPolicy: IfNotPresent
            name: konflux-ci-pull-request-builds-pruner
            resources:
              limits:
                cpu: 500m
                memory: 512Mi
              requests:
                cpu: 150m
                memory: 128Mi
            securityContext:
              readOnlyRootFilesystem: true
            volumeMounts:
            - mountPath: /image-pruner
              name: konflux-ci-pull-request-builds-pruner-volume
          restartPolicy: OnFailure
          securityContext:
            runAsNonRoot: true
          volumes:
          - configMap:
              name: single-image-pruner-configmap-f4hc5877h6
            name: konflux-ci-pull-request-builds-pruner-volume
          - name: konflux-ci-pull-request-builds-pruner-token
            secret:
              secretName: konflux-ci-pull-request-builds-pruner-token
  schedule: 0 1 * * *
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: redhat-appstudio-pr-cronjob
  namespace: image-controller
spec:
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - command:
            - /bin/bash
            - -c
            - python /image-pruner/prune_images.py --namespace=redhat-appstudio --repo-name=pull-request-builds
            env:
            - name: QUAY_TOKEN
              valueFrom:
                secretKeyRef:
                  key: quaytoken
                  name: redhat-appstudio-pr-token
            image: registry.redhat.io/rhel8/python-39:1-120.1684740828
            imagePullPolicy: IfNotPresent
            name: redhat-appstudio-pr-pruner
            resources:
              limits:
                cpu: 500m
                memory: 512Mi
              requests:
                cpu: 150m
                memory: 128Mi
            securityContext:
              readOnlyRootFilesystem: true
            volumeMounts:
            - mountPath: /image-pruner
              name: redhat-appstudio-pr-volume
          restartPolicy: OnFailure
          securityContext:
            runAsNonRoot: true
          volumes:
          - configMap:
              name: single-image-pruner-configmap-f4hc5877h6
            name: redhat-appstudio-pr-volume
          - name: redhat-appstudio-pr-token
            secret:
              secretName: redhat-appstudio-pr-token
  schedule: 0 0 * * *
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-1"
  name: konflux-ci-pull-request-builds-pruner-token
  namespace: image-controller
spec:
  dataFrom:
  - extract:
      key: production/build/konflux-ci-pull-request-builds-pruner-token
  refreshInterval: 20h
  secretStoreRef:
    kind: ClusterSecretStore
    name: appsre-stonesoup-vault
  target:
    creationPolicy: Owner
    deletionPolicy: Delete
    name: konflux-ci-pull-request-builds-pruner-token
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-1"
  name: quaytoken
  namespace: image-controller
spec:
  dataFrom:
  - extract:
      key: production/build/image-controller
  refreshInterval: 5m
  secretStoreRef:
    kind: ClusterSecretStore
    name: appsre-stonesoup-vault
  target:
    creationPolicy: Owner
    deletionPolicy: Delete
    name: quaytoken
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-1"
  name: redhat-appstudio-pr-token
  namespace: image-controller
spec:
  dataFrom:
  - extract:
      key: production/build/redhat-appstudio-pr-token
  refreshInterval: 20h
  secretStoreRef:
    kind: ClusterSecretStore
    name: appsre-stonesoup-vault
  target:
    creationPolicy: Owner
    deletionPolicy: Delete
    name: redhat-appstudio-pr-token
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: image-controller
  namespace: image-controller
spec:
  endpoints:
  - bearerTokenSecret:
      key: token
      name: metrics-reader
    interval: 15s
    path: /metrics
    port: https
    scheme: https
    tlsConfig:
      insecureSkipVerify: true
  selector:
    matchLabels:
      control-plane: controller-manager
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    control-plane: controller-manager
  name: image-controller-controller-manager-metrics-monitor
  namespace: image-controller
spec:
  endpoints:
  - bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
    path: /metrics
    port: https
    scheme: https
    tlsConfig:
      insecureSkipVerify: true
  selector:
    matchLabels:
      control-plane: controller-manager
